var assert = require('assert');
var Q = require('q');
var passwd = require('etc-passwd');

var nos = require('../nos');

var isRoot = process.getuid ? process.getuid() === 0 : false;

describe("nos", function () {
  it("should return a ChildProcess instance", function (done) {
    nos('ls').done(function (command) {
      assert(command.pid, "pid not found");
      done();
    });
  });

  it("should output debugging info if debug option set", function (done) {
    var oldLog = console.log;
    var output = [];
    console.log = function (message) {
      output.push(message);
      oldLog.apply(this, arguments);
    };
    nos('ls', {debug: true}).done(function (command) {
      assert.notStrictEqual(output.indexOf('nos debug: ls'), -1, "debugging info not output");
      console.log = oldLog;
      done();
    });
  });

  it("should fail with an invalid user", function (done) {
    nos('ls', {user: 'i_hope_you_dont_have_a_user_called_this'})
      .then(function () {
        assert(false, "command succeeded with invalid user");
      })
      .fail(function () {}) // failure means success
      .done(done);
  });
  it("should fail with an invalid group", function (done) {
    nos('ls', {group: 'i_hope_you_dont_have_a_group_called_this'})
      .then(function () {
        assert(false, "command succeeded with invalid group");
      })
      .fail(function () {}) // failure means success
      .done(done);
  });

  (isRoot ? describe : describe.skip)("called as root", function () {
    it("should spawn with the specified user", function (done) {
      var user = 'nobody';
      Q
        .all([nos('ls', {user: user}), Q.ninvoke(passwd, 'getUser', {username: user})])
        .spread(function (command, user) {
          assert.strictEqual(command._spawnOpts.uid, user.uid, "uid invalid");
          assert.strictEqual(command._spawnOpts.env.HOME, user.home, "$HOME not correct for new user");
        })
        .done(done);
    });
    it("should spawn with the specified group", function (done) {
      var group = 'nogroup';
      Q
        .all([nos('ls', {group: group}), Q.ninvoke(passwd, 'getGroup', {groupname: group})])
        .spread(function (command, group) {
          assert.strictEqual(command._spawnOpts.gid, group.gid, "gid invalid");
        })
        .done(done);
    });
  });

  describe(".wait", function () {
    it("should return a closed ChildProcess instance", function (done) {
      nos('ls').wait().done(function (command) {
        assert.strictEqual(typeof command.exitCode, 'number', "process not closed");
        done();
      });
    });
    it("should fail if the process failed", function (done) {
      nos('i_hope_you_dont_have_a_command_called_this').wait()
        .then(function (command) { assert(false, "didn't fail"); })
        .fail(function (code) {
          assert.strictEqual(typeof code, 'number', "return code non-numeric");
          assert.notStrictEqual(code, 0, "return code successful");
        })
        .done(done);
    });
  });
  describe(".read", function () {
    it("should return a buffer after stdout has closed", function (done) {
      var ls = nos('ls');
      Q
        .all([ls, ls.read()])
        .spread(function (command, buf) {
          assert(buf instanceof Buffer, "buf not a Buffer");
          assert(command.stdout.destroyed, "stdout not closed yet");
        })
        .done(done);
    });
  });
});
