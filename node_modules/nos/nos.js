var Q = require('q');
var parse = require('shell-quote').parse;
var extend = require('extend');
var child_process = require('child_process');
var _ = require('underscore');
var passwd = require('etc-passwd');

function nos (command, options) {
  var options = options || {};
  var result = nos._getSpawnOpts(options).then(function (spawnOpts) {
    var parsedCommand = parse(command);
    if (options.debug) console.log('nos debug: ' + command);

    var result = extend(child_process.spawn(parsedCommand[0], parsedCommand.slice(1), spawnOpts), {
      _spawnOpts: spawnOpts,
      _parsedCommand: parsedCommand
    });
    result.on('error', _.identity); // handle errors via Q
    return result;
  });

  return _.bindAll.apply(_, [extend(result, nos._methods)].concat(_.functions(nos._methods)));
}
nos._methods = {
  wait: function () {
    return this.then(function (command) {
      return Q.nmcall(command, 'on', 'close').thenResolve(command);
    });
  },
  read: function () {
    return this.then(function (command) { return nos.readStream(command.stdout); });
  }
};
nos._getSpawnOpts = function (options) {
  var promise = Q(options);

  if (options.user) {
    promise = Q
      .all([promise, Q.ninvoke(passwd, 'getUser', {username: options.user})])
      .spread(function (options, user) {
        return extend(true, {uid: user.uid, env: {HOME: user.home}}, options);
      });
  }

  if (options.group) {
    promise = Q
      .all([promise, Q.ninvoke(passwd, 'getGroup', {groupname: options.group})])
      .spread(function (options, group) { return extend({gid: group.gid}, options); });
  }

  return promise;
};
nos.readStream = function (stream) {
  var buffers = [];
  stream.on('data', buffers.push.bind(buffers));
  return Q.nmcall(stream, 'on', 'end').then(function () { return Buffer.concat(buffers); });
};

module.exports = nos;
